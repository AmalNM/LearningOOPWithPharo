{ "metadata": { 
	"title": "Learning Object-Oriented Programming, Design and TDD with Pharo (vol I)" ,
	"attribution" : "Stéphane Ducasse with Alain Plantec"} } 

${inputFile:Chapters/Introduction/Introduction.pillar}$

! Getting in touch with Pharo

%${inputFile:Chapters/PlayingWithTurtles/PlayingWithTurtles.pillar}$

${inputFile:Chapters/GettingStarted/GettingStarted.pillar}$ 

${inputFile:Chapters/Counter/Counter.pillar}$ 

${inputFile:Chapters/Tests/Tests.pillar}$ 
Turn the examples given in the first chapter into test

${inputFile:Chapters/Katas/GramKatas.pillar}$

%${inputFile:Chapters/Katas/GramVariation.pillar}$

! About Objects and Classes
In this book part we suggest to read carefully the next chapter and after to do the following ones.
Since the following chapters are extremely simple exercises it can be tedious to do them all.

${inputFile:Chapters/OOPNutshell/OOPNutshell.pillar}$

${inputFile:Chapters/Converter/Converter.pillar}$

${inputFile:Chapters/Wallet/Wallet.pillar}$

${inputFile:Chapters/DSL/DSL.pillar}$

!! Tamagoshi (graphics TBMigrated :))

!! Do we do Joe the Box

%${inputFile:Chapters/JoeTheBox/JoeTheBox.pillar}$


! Looking at Inheritance

${inputFile:Chapters/Inheritance/Inheritance.pillar}$

${inputFile:Chapters/SimpleLAN/SimpleLANDefinition.pillar}$

! Little Projects

${inputFile:Chapters/SnakesAndLadders/SnakesAndLadders.pillar}$

${inputFile:Chapters/TinyChat/TinyChat.pillar}$

${inputFile:Chapters/BeaconAndSatellite/BeaconAndSatellite.pillar}$




! Second Volume 

${inputFile:Chapters/SyntaxGlimpse/SyntaxGlimpse.pillar}$ 

${inputFile:Chapters/Expressions/Expressions.pillar}$


! Sending messages

${inputFile:Chapters/MessageSending/MessageSending.pillar}$

${inputFile:Chapters/PaperStoneScissor/PaperStoneScissor.pillar}$

!! Playing with Visitors

Here I should take the slides flow from the design mooc lectures. 
Visitor then after I should make sure that we only return expressions
of the same domain and with a stack.


!! Playing with Interpreters

Returning an integer is not really nice because we cross boundaries.

!!! Using the Pharo execution stack

[[[
EEvaluator >> visitMultiplication: aMultiplication
	^ (EConstant new
		value: (self evaluate: aMultiplication left) * 
					(self evaluate: aMultiplication right)  
]]]

!!! With an explicit interpretation  stack
[[[
EEvaluator >> visitMultiplication: aMultiplication
	self evaluate: aMultiplication left.
	self evaluate: aMultiplication right.
	self push: (EConstant new
					value: self pop value * self pop value)  
]]]

!! Parsing alain?

!! Ants?

!! About Design

!!! Move behavior close to the data

!!! Interface
Program to an interface, not an implementation

Depend on interfaces, not concrete classes

!!! The Open-Closed Principle
Design classes and packages so their functionality can be extended without modifying the source code.
This can be achieved by using inheritance to override and extend inherited behaviour.
Bertrand Meyer. Object Oriented Software Construction, 1988.
See also the “Template Method” pattern in the Design Patterns book

!!! About delegation
“Don’t do anything you can push off to someone else.”
 Joseph Pelrine

Do not take over the responsibilities of other objects. If an object is in charge of certain information, you should delegate related tasks to that object, rather than trying to handle them yourself.
For a player to move forward, it must find out what square it ultimately lands on, but it is the responsibility of the squares on the board to interpret the logic of the game.
For a square to let a player move forward one position, it needs to find out what is the next square on the board, but it is the responsibility of the game to keep track of this.
(Note that we are free to distribute responsibilities as we choose, but we should also make sure that no object is overloaded with responsibilities

Once and only once
“In a program written with good style, everything is said once and only once.”

Lots of little pieces
“Good code invariably has small methods and small objects. Only by factoring the system into many small pieces of state and function can you hope to satisfy the ‘once and only once’ rule.”

If you see similar logic repeated in many methods, this is a sign that the design has not been carefully thought through.
Long methods tend to be a sign of procedural thinking. Small methods are a hallmark of OO thinking.
See the introduction to:
Kent Beck, Smalltalk Best Practice Patterns, Prentice-Hall, 1997

!!! Composed method
Divide  your program into methods that perform one identifiable task.
- Keep all of the operations in a method at the same level of abstraction.
- This will naturally result in programs with many small methods, each a few lines long.

If a method is too long, take groups of statements doing related things and encapsulate them in a (protected) helper methods.
Name those methods after what the statements are doing.

!!! Name well

es should be chosen to reveal the intent of the code.
In the sample code, the point is not that we want to get the square numbered 1, but that we want the first square of the game. Similarly we want to express that this player is entering the square, not how this is achieved at a low level.
Whenever you find yourself writing procedural code, extract that code into declaratively named methods that express what that code is doing.

!!! Don't ask, tell



! Volume 3

!! Uno?

!! Ants

!! Project:  Managing Game Collection (TBD)

!! Project: Sokoban (TB DONE)

!! Project: LSystem (TBMigrated)

Lindermayer systems, also called ''L-Systems'', have been developed
by biology theorists to understand and simulate the growth of plants
cite|Pruz90a. In the following chapters we propose you to implement
different L-Systems from a minimalist to elaborate
ones. Chapter ch:lsystem presents the simplest possible
L-Systems, i.e., L-System composed by one single rule.
Chapter ch:lsystem2 presents an object-oriented model of
L-System that alleviate the limits of the previous implementation.
Chapter ch:plant defines a new class of turtle that allows one
to model plants with the L-Systems defined previously. Finally,
Chapter ch:parametric introduces Parametric L-Systems that
allows one to express more powerful L-Systems. This chapter shows in
particular how inheritance can be used to reuse class already defined.

!!! Lindermayer Systems
	MyBooks/botsinc/BookTwo/Debugger/

!!!	LSystem
	getting started
!!!	AdvancedL-Systems	
	rules
!!!	PlantModeling
	stack turtle
	
!! Project:  Game Of Life (TBEvaluated)
with conditionals and polymorphism

%!! Project: Path-finder (it is graphical so out or should get a textual version)

!! Classes are objects too

May be at the end of the book: class are objects too. 
	Model2 in MyBooks/botsinc/BookTwo/SyntaxAndModel2


! Extra teaching materia

! Solutions 	
${inputFile:Chapters/Solutions/Solutions.pillar}$

%! Appendix
%${inputFile:Chapters/SyntaxNutshell/SyntaxNutshell.pillar}$