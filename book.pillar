{ "metadata": { 
	"title": "Learning Object-Oriented Programming, Design and TDD with Pharo" ,
	"attribution" : "Stéphane Ducasse"} } 



${inputFile:Chapters/Introduction/Introduction.pillar}$


! Getting in touch with Pharo

%${inputFile:Chapters/PlayingWithTurtles/PlayingWithTurtles.pillar}$

!! A glimpse at syntax

${inputFile:Chapters/Tests/Tests.pillar}$
 
Turn the examples given in the first chapter into test

${inputFile:Chapters/Katas/GramKatas.pillar}$

%${inputFile:Chapters/Katas/GramVariation.pillar}$

${inputFile:Chapters/Counter/Counter.pillar}$ 

! About Objects and Classes
In this book part we suggest to read carefully the next chapter and after to do the following ones.
Since the following chapters are extremely simple exercises it can be tedious to do them all.

${inputFile:Chapters/OOPNutshell/OOPNutshell.pillar}$


${inputFile:Chapters/ObjectsAndClasses/ObjectsAndClasses.pillar}$

${inputFile:Chapters/Converter/Converter.pillar}$

${inputFile:Chapters/Wallet/Wallet.pillar}$

${inputFile:Chapters/DSL/DSL.pillar}$

!! Tamagoshi (graphics TBMigrated)

${inputFile:Chapters/JoeTheBox/JoeTheBox.pillar}$


! Looking at Inheritance

${inputFile:Chapters/Inheritance/Inheritance.pillar}$

${inputFile:Chapters/SimpleLAN/SimpleLANDefinition.pillar}$

${inputFile:Chapters/Expressions/Expressions.pillar}$


! Sending messages

!! Sending a message is making a choice

Sending a message is doing a choice: it is selecting the method that is defined for the receiver

When we execute a method, one key information we get is that the method is that receiver is from this class or one of its subclasses

Classes represent choices. 

!!! Summing and converting money

We will now work on one example proposed by A. Bergel in the Pharo mailing-list and we would like to thank him for it. 
[[[
1 EUR = 662 CLP (Chilean pesos) 
]]]



You have a class Money to which you can sum other money. 

[[[
Object subclass: #Money 
	instVarNames: ‘value’ 
]]]

[[[
Money >> + anotherMoney 
   self subclassResponsibility 
]]]

[[[
Money >> sumWithEUR: money 
   self subclassResponsibility 
]]]

[[[
Money >> sumWithCLP: money 
   self subclassResponsibility 
]]]

[[[
Money >> = anotherMoney 
  ^ self class == anotherMoney class and: [ self value = anotherMoney value ] 
]]]

[[[
Money >> printOn: str 
   super printOn: str. 
   str nextPut: $<. 
   str nextPutAll: self value asString. 
   str nextPut: $>. 
]]]

You have two subclasses: 
Money subclass: #EUR 
Money subclass: #CLP 

[[[
EUR>>+ anotherMoney 
        ^ anotherMoney sumWithEUR: self 

EUR>>sumWithEUR: money 
        ^ EUR new value: self value + money value 

EUR>>sumWithCLP: money 
        ^ CLP new value: (self value * 662) + money value 

CLP>>+ anotherMoney 
        ^ anotherMoney sumWithCLP: self 

CLP>>sumWithEUR: money 
        ^ EUR new value: (self value / 662) + money value 

CLP>>sumWithCLP: money 
     ^ CLP new value: self value + money value 
]]]


	Here is a test: 
	TestCase subclass: #MoneyTest 

[[[
MoneyTest >> testSum 
   | clp1 eur1 clp2 eur2 |
   clp1 := CLP new value: 3500.
   eur1 := EUR new value: 10.
   clp2 := CLP new value: 5000.
   eur2 := EUR new value: 20.

   self assert: clp1 + clp2 equals: (CLP new value: 8500). 
   self assert: clp1 + eur1 equals: (CLP new value: 3500 + 6620).
        
   self assert: eur1 + eur2 equals: (EUR new value: 30).
   self assert: eur1 + clp2 equals: (EUR new value: 5000 / 662 + 10).
]]]

${inputFile:Chapters/PaperStoneScissor/PaperStoneScissor.pillar}$

!! About Design

!!! Move behavior close to the data
!!! 
Program to an interface, not an implementation

Depend on interfaces, not concrete classes

!!! The Open-Closed Principle
Design classes and packages so their functionality can be extended without modifying the source code.
This can be achieved by using inheritance to override and extend inherited behaviour.
Bertrand Meyer. Object Oriented Software Construction, 1988.
See also the “Template Method” pattern in the Design Patterns book

!!! About delegation
“Don’t do anything you can push off to someone else.”
 Joseph Pelrine

Do not take over the responsibilities of other objects. If an object is in charge of certain information, you should delegate related tasks to that object, rather than trying to handle them yourself.
For a player to move forward, it must find out what square it ultimately lands on, but it is the responsibility of the squares on the board to interpret the logic of the game.
For a square to let a player move forward one position, it needs to find out what is the next square on the board, but it is the responsibility of the game to keep track of this.
(Note that we are free to distribute responsibilities as we choose, but we should also make sure that no object is overloaded with responsibilities

Once and only once
“In a program written with good style, everything is said once and only once.”

Lots of little pieces
“Good code invariably has small methods and small objects. Only by factoring the system into many small pieces of state and function can you hope to satisfy the ‘once and only once’ rule.”

If you see similar logic repeated in many methods, this is a sign that the design has not been carefully thought through.
Long methods tend to be a sign of procedural thinking. Small methods are a hallmark of OO thinking.
See the introduction to:
Kent Beck, Smalltalk Best Practice Patterns, Prentice-Hall, 1997

!!! Composed method
Divide  your program into methods that perform one identifiable task.
- Keep all of the operations in a method at the same level of abstraction.
- This will naturally result in programs with many small methods, each a few lines long.

If a method is too long, take groups of statements doing related things and encapsulate them in a (protected) helper methods.
Name those methods after what the statements are doing.

!!! Name well

es should be chosen to reveal the intent of the code.
In the sample code, the point is not that we want to get the square numbered 1, but that we want the first square of the game. Similarly we want to express that this player is entering the square, not how this is achieved at a low level.
Whenever you find yourself writing procedural code, extract that code into declaratively named methods that express what that code is doing.

!!! Don't ask, tell



!! Playing with Visitors

Here I should take the slides flow from the design mooc lectures. 



! Project:  Managing Game Collection (TBD)

! Project: TinyChat (TBIncluded)

! Project: Sokoban (TB DONE)

! Project: LSystem (TBMigrated)

Lindermayer systems, also called ''L-Systems'', have been developed
by biology theorists to understand and simulate the growth of plants
cite|Pruz90a. In the following chapters we propose you to implement
different L-Systems from a minimalist to elaborate
ones. Chapter ch:lsystem presents the simplest possible
L-Systems, i.e., L-System composed by one single rule.
Chapter ch:lsystem2 presents an object-oriented model of
L-System that alleviate the limits of the previous implementation.
Chapter ch:plant defines a new class of turtle that allows one
to model plants with the L-Systems defined previously. Finally,
Chapter ch:parametric introduces Parametric L-Systems that
allows one to express more powerful L-Systems. This chapter shows in
particular how inheritance can be used to reuse class already defined.

!! Lindermayer Systems
	MyBooks/botsinc/BookTwo/Debugger/

!!!	LSystem
	getting started
!!!	AdvancedL-Systems	
	rules
!!!	PlantModeling
	stack turtle
	
!! Project:  Game Of Life (TBEvaluated)
with conditionals and polymorphism

!! Project: Path-finder (it is graphical so out or should get a textual version)

!! Classes are objects too

May be at the end of the book: class are objects too. 
	Model2 in MyBooks/botsinc/BookTwo/SyntaxAndModel2

! Extra teaching materia

! Solutions 	
${inputFile:Chapters/Solutions/Solutions.pillar}$

! Appendix

${inputFile:Chapters/SyntaxNutshell/SyntaxNutshell.pillar}$