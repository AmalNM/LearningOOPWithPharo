!! Snakes and Ladders
@cha:started


Snakes and Ladders is a rather simple game suitable for teaching children how to apply rules (*http://en.wikipedia.org/wiki/Snakes_and_ladders*). It is dull for adults because there is absolutely no strategy involved, but this makes it easy to implement! 
In this chapter you will implement SnakesAndLadders and we use it as a pretext to explore design questions.

+Snakes and Ladders: one possible board game with two ladders and one snake.>file://figures/snakesAndLadders.png|width=70|label=fig:snakes+


!!! Game Rules
Snakes and Ladders originated in India as part of a family of dice games. The game was introduced in England as "Snakes and Ladders" (see Figure *@fig:snakes*), then the basic concept was introduced in the United States as ''Chutes and Ladders''.
Here is a little description of the rules: 
- ""Players:"" Snakes and Ladders is played by two to four players, each with her/his own token to move around the board.
- ""Moving Player"": a player rolls a die, then moves the designated number of tiles, between one and six. Once he lands on a tile, she/he has to perform any action designated by the tile. (Since the rules are fuzy we decided that we can have multiple players in the same tile).
- ""Ladders:"" If the tile a player lands on is at the bottom of a ladder, she/he should climb the ladder, which brings him to a space higher on the board.
- ""Snakes:"" If the tile a player lands on is at the top of a snake, she/he must slide down to the bottom of it, landing on a tile closer to the beginning.
- ""Winning:"" the winner is the player who gets to the last tile first, whether by landing on it from a roll, or by reaching it with a ladder. We  decided that when the player does not land directly on the last tile, it does not move.

!!! Game possible run
The following snippet is a possible way to program this game. We take as a board configuration the one depicted in Figure *fig:snakes*. It defines that our board game is composed of 12 tiles and have two ladders and one snake. Then two players are added. 
And the game starts. 

[[[
| jill jack game |
game := SLGame new tileNumber: 12.
game 
	setLadderFrom: 2 to: 6;
	setLadderFrom: 7 to: 9;
	setSnakeFrom: 11 to: 5.
game 
	addPlayer: (SLPlayer new name: 'Jill');
	addPlayer: (SLPlayer new name: 'Jack'). 
game play
]]]

You will develop a textual version of the game since we want to focus on the game logic 
and avoid lengthly UI descriptions. 

The following is a possible game execution: two players are on the first tile. 
We see that the board displays the two ladders and one snake. 
Then starting from Jill they drew and roll a dice and go to the corresponding tile and follow its effect.
[[[
[1<Jill><Jack>][2->6][3][4][5][6][7->9][8][9][10][5<-11][12]
<Jill>drew 3: [1<Jack>][2->6][3][4<Jill>][5][6][7->9][8][9][10][5<-11][12]
<Jack>drew 6: [1][2->6][3][4<Jill>][5][6][7->9][8][9<Jack>][10][5<-11][12]
<Jill>drew 5: [1][2->6][3][4][5][6][7->9][8][9<Jack><Jill>][10][5<-11][12]
<Jack>drew 1: [1][2->6][3][4][5][6][7->9][8][9<Jill>][10<Jack>][5<-11][12]
<Jill>drew 3: [1][2->6][3][4][5][6][7->9][8][9][10<Jack>][5<-11][12<Jill>]
]]]

!!! Potential objects and responsibilities

Look at the game rules, take a piece of paper and list the potential objects and their behavior. It is an important exercise, you should train to see how to discover potential objects and from then their classes.

There exist techniques such Responsibility Driven Design to help programmers during such phase. Responsibility Driven Design suggests to analyse the documents describing a project and to turn  subjects of sentences into objects and verbs are grouped into behavior of the objects. 
Identification of synonyms is used to reduce and gather together similar objects or behavior. 
Then later objects are grouped into classes. Some alternate approaches look for patterns between objects such as part-whole, locations, entity-owner... This could be the topic of a full book.

Here we follow another path:  sketching scenarii. We describe some scenarii and from such scenario we identify key playing objects.

- Scenario 1. The game should be created with a number of tiles. In particular the end and start tiles should exist. Ladders and snakes should be declared.
- Scenario 2. Players are declared. They start on the first tiles. 
- Scenario 3. When player rolls a dice, he should move the number of tiles given by the dice.
- Scenario 4. After moving the first player a given number of tiles based on the result of dice roll, this is the turn of the second player.
- Scenario 5. When a player arrives to a ladder start, it should be moved to the ladder end.
- Scenario 6. When a player should move further than the end tile, he does not move.
- Scenario 7. When a player ends its course on the end tile, he wins and the game is finished.

Such scenarii are interesting because they are a good basis for tests.

!!!! Possible class candidates

When reading the rules and the scenario, here is a list of possible classes that we could use.
We will refine it later and remove double or overlapping concepts.

- Game: it keeps track of the game state whose turn is, the players.
- Board: it keeps the tile configuration. 
- Player: it keeps track of where it is on the board and moves over tiles.
- Tile: it keeps track of any player on it. 
- Snake: it is special tile, it sends a player back to an earlier tile.
- Ladder: it is a special tile, it sends a player ahead to a later tile.
- Last Tile: players should land exactly on it, else they do not move.
- First Tile: it holds multiple players at the beginning of the game.
- Die: it rolls and returns a number depending on its face number. 

It is not clear if all the ojects we identify by looking at the problem and its scenario should be really turned into real objects. Also sometimes it is useful to get more classes to capture behavior and state variations. We should look to have an exact mapping between concepts identified in the problem scenario or description and the implementation. 

From analysing this list we can draw some observations: 
- Game and Board are probably the same concept and we can merge them.
- Die may be overkill. Having a full object just to produce a random number may not be worth, especially since we do not have a super fancy user interface showing the dice rolling and other effect. 
- Tile, Snake, Ladder, Last and First Tile all look like tiles with some variations or specific actions. We suspect that we can reuse some logic by creating an inheritance hierarchy around the concept of Tile. 

!!!! About representation 

We can implement the same system using different implementation choices. For example we could have only one class implementing all the game logic and it would work. Some people may also 
argue that this is not a bad solution.

Object-oriented design favors the distribution of the state of the system to different objects.
It is often better to have objects with clear responsibilities. Why? Because you should consider that you will have to rethink, modify or extend your system. We should be able to understand and extend easily a system to be able to reply to new requirements.  

So while for a simple game not having a nice object-oriented decomposition may not be a problem, as soon as you will start to  model a more complex system not having a good decomposition will hurt you. Real life applications often have a lifetime up to 25 years. 


!!! About object-oriented design

When designing a system, you will often have questions that cannot be blindly and automatically answered. Often there is no definite answer. This is what is difficult with object-oriented design and this is why practicing is important. 

What composes the state of an object?
The state of object should characterize the object over its lifetime. For example the name of  player identifies the player.

Now it may happen that some objects just because they are instances of different classes
do not need the same state but still offer the same set of messages. For example the tiles and the ladder/snake tiles have probably a similar API but snake and ladder should hold information of their target tile.

We can also distinguish between the intrinsic state of an object (e.g., name of player) and the state we use to represent the collaborators of an object. 

The other important and difficult question is about the relationships between the objects. 
For example imagine that we model a tile as an object, should this object points to the players it contains. Similarly, should a tile knows its position or just the game should know the position of each tile. 

Should the game object keep the position of the players or just the player. 
The game should keep the players list since it should compute who is the next player.

!!!! CRC cards
Some designers use CRC (for Class Responsibility Collaborators) cards: 
the idea is to take the list of class we identified above. For each of them, we write on a little card: the class name, its responsibility in one or two sentence and list its collaborators. Once this is done, they take the scenario and see how the objects can play the scenario. Doing so they refine their design by adding more information (collaborators) to a class. 

!!!! Some heuristics
To help us taking decision, that are some heuristics: 
- One object should have one main responsibility.
- Move behavior close to data. If a class defines the behavior of another object, there is a good chance that other clients of this object are doing the same and create duplicated and complex logic. If an object defines a clear behavior, clients just invoke it without duplicating it.
- Prefer domain object over literal objects. As a general principle it is better to get a reference to a more general objects than a simple number. Because we can then invoke a larger set of behavior. 



!!!! Kind of data passed around
Even if in Pharo, everything is an object, storing a mere integer object instead of a full tile can lead to different solutions. There is no perfect solution mainly consequences of choices and you should learn how to assess a situation to see which one has better characteristics for your problem. 

Here is a question illustrating the problem: Should a ladder knows the tile it forwards the player to or is the index of a tile enough?

When designing the ladder tile behavior, we should understand how we can
access the target tile where the player should be moved to. 
If we just give the index of the target to a ladder, the tile has to be able to access the board containing the tiles else it will be impossible to access to the target tile of the ladder. The alternative, i.e., passing the tile looks nicer because it represents a natural relation and there is no need to ask the board. 


!!!! Agility to adapt

In addition it is important not to get stressed, writing tests that represent parts  or scenario 
we want to implement is a good way to make sure that we can adapt in case we discover that we missed a point. 

Now this game is interesting also from a test point of view because it may be difficult to test the parts in isolation (i.e., without requiring to have a game object).


!!! Let us get started

You will follow an iterative process and test first approach. You will take scenario implement a test and define the corresponding classes. 

This game implementation raises an interesting question which is how do we test the game state
without hardcoding too much implementation details in the tests themselves. Indeed tests that validate scenario only involving public messages and high-level interfaces are more likely to be stable over time and do not require modifications. Indeed if we check the exact class of certain objects you will have to change the implementation as well as the tests when modifying the implementation. In addition, since in Pharo the tests are normal clients of the objects they test, writing some tests may force us to define extra methods to access to private data. 

But enough talking let's getting started.
Let us start by defining a test class named ==SLGameTest==. We will see in the course of development if we define other test classes. Our feeling is that the tiles and players are objects with limited responsibility and their responsibility is best illustrated (and then tested) when they interact with each other in the context of a given game. Therefore
the class ==SLGameTest== describes the place in which relevant scenario will occur. 

Define the class ==SLGameTest==.

[[[
TestCase subclass: #SLGameTest
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'SnakesAndLadders'
]]]

One of the first scenario that we would like to define it that a game is composed of a certain number of tiles. 

We can write a test has follows but it does not have a lot of value. At the beginning of the development this is normal to have limited tests because we do not have enough objects to interact with. 

[[[
SLGameTest >> testCheckingSimpleGame

	| game |
	game := SLGame new tileNumber: 12.
	self assert: game tileNumber equals: 12
]]]

Now we should make this test pass. Some strong advocates of TDD say that we should code 
the first simplest method that would make the test pass and go to the next one. 
Let us see what it would be (of course this method will be changed later).

First we should define the class ==SLGame==.

[[[
Object subclass: #SLGame
	instanceVariableNames: 'tiles'
	classVariableNames: ''
	package: 'SnakesAndLadders'
]]]

Now you can define the methods ==tileNumber:== and ==tileNumber==. This is not really nice
because we should get a collection of hold the tiles and now we put a number.

[[[
SLGame >> tileNumber: aNumber
	tiles := aNumber
]]]


[[[
SLGame >> tileNumber
	^ tiles
]]]

These method definitions are enough to make our test pass. So it means that our test was not that good.

!!! A first real test

Since we would like to be able to check that our game is correct we can use its textual representation and test it as a way to check the game state. 
The following test should what we want. 

[[[
SLGameTest >> testPrintingSimpleGame

	| game |
	game := SLGame new tileNumber: 12.
	self 
		assert: game printString 
		equals: '[1][2][3][4][5][6][7][8][9][10][11][12]'
]]]

What we would like is that the printing of the game asks the tiles to print themselves this way we will be able to take advantage that there will be different tiles in a modular way: i.e. we will not change the game to display the ladder and snake just have different tiles with different behavior. 

The first step is then to define a class named ==SLTile== as follows:

[[[
Object subclass: #SLTile
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'SnakesAndLadders'
]]]

Now we would like to test the printing of a single tile. So let us define a test case named ==SLTileTest==. This test case will test some basic behavior but it is nice to decompose our
implementation process. We are trying to minimize the gap between one functionality and one test.

[[[
TestCase subclass: #SLTileTest
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'SnakesAndLadders'
]]]

Now we can write a simple test to make sure that we can print a tile.

[[[
SLTileTest >> testPrinting

	| tile |
	tile := SLTile new position: 6.
	self assert: tile printString equals: '[6]'
]]]

Tile position could have been managed by the game itself.  But it means that we would have to ask the game for the position of a given tile and while it would work, it does not feel good.
This is where you see that the fact that the code is running is not a quality test for good Object-Oriented Design. In Object-Oriented Design, we should distribute responsibilities to objects and their state is the first responsibilities. Since the position is an attribute of a position, better define it there.

In particular it means that we should add an accessor to set the position and to add an instance variable ==position== to the class. Execute the test and follow the request of the IDE and you will have defined this accessor and the instance variable. 


Now we can define the ==printOn:== method for tiles as follows.

[[[
SLTile >> printOn: aStream

	aStream << '['.
	aStream << position printString.
	aStream << ']'
]]]

Your tile test should pass now. And we are ready to finish the printing of the game itself. 
Now we can define the method ==printOn:== of the game to print all its tiles.
Note that this will not work since so far we did not create tiles. 

[[[
SLGame >> printOn: aStream

	tiles do: [ :aTile | 
		aStream << aTile printString ]
]]]

We modify the method ==tileNumber:== to create an array of the given size and store it inside the ==tiles== instance variable and to put a new tile for each position. Pay attention the tile should have the correct position.

[[[
SLGame >> tileNumber: aNumber
	...
]]]

Now you printing tests should be working both for the tile and the game. 
But wait if we run the test ==testCheckingSimpleGame== it fails.
Indeed we did not change the definition ==tileNumber==.
Do it and make sure that your tests all pass. And save your code. 

!!! Accessing one tile

Now we will need to be able to ask the game for a given tile, for example with the message ==tileAt:==. Let us add a test for it. 

[[[
SLGameTest >> testTileAt

	| game |
	game := SLGame new tileNumber: 12.
	self assert: (game tileAt: 6) printString equals: '[6]'
]]]

Define the method.

[[[
SLGame >> tileAt: aNumber
	...
]]]


!!! Adding players

Now we should add players. The first scenario to test is that when we add a player to game, it should be one the first tile.

Let us write test: we create a game and a player. Then we add the player to the game and the player should be part of the players of the first tile. 

[[[
SLGameTest >> testPlayerAtStart

	| game jill |
	game := SLGame new tileNumber: 12.
	jill := SLPlayer new name: 'Jill'.
	game addPlayer: jill. 
	self assert: ((game tileAt: 1) players includes: jill).
]]]


[[[
Object subclass: #SLPlayer
	instanceVariableNames: 'name'
	classVariableNames: ''
	package: 'SnakesAndLadders'
]]]

Define the method ==name:== in the class ==SLPlayer==
Now we should think a bit how we should manage the players. 
We suspect that the game itself should get a list of players so that in the future it can ask each player to play its turn. Notice the previous sentence: we say each player to play and not the game to play the next turn - again this is Object-Oriented Design in action.

Now our test does not really cover the point that the game should keep track of the players
so we will not do it. Similarly we may wonder if a player should know its position. At this point we do not know and we postpone this decision for another scenario.

[[[
SLGame >> addPlayer: aPlayer	
	(tiles at: 1) addPlayer: aPlayer
]]]

Now what is clear is that a tile should keep a player list. Add an instance variable ==players== to the ==SLTile== class and initialize it to be an OrderedCollection. 

[[[
SLTile >> initialize
	...
]]]

Then implement the method ==addPlayer:==

[[[
SLTile >> addPlayer: aPlayer
	...
]]]

Now all your test should pass.

Let us the opportunity to write better tests. We should check that we can add two players and that both are on the starting tile. 

[[[
SLGameTest >> testSeveralPlayersAtStart

	| game jill jack |
	game := SLGame new tileNumber: 12.
	jill := SLPlayer new name: 'Jill'.
	jack := SLPlayer new name: 'Jack'.
	game addPlayer: jill.
	game addPlayer: jack.
	self assert: ((game tileAt: 1) players includes: jill).
	self assert: ((game tileAt: 1) players includes: jack).

]]]

This  test should pass and this is the time to save and take a break. 

+Playground in action. Use Do it and go - to get an embedded inspector.>file://figures/playground.png|width=70|label=fig:snakesplay+

!!! About tools

Pharo is living environment so we can interact with the objects. Let us see a bit that.

Type the following game creation in a playground (as shown here *fig:snakesplay*).
[[[
| game jill jack |
game := SLGame new tileNumber: 12.
jill := SLPlayer new name: 'Jill'.
jack := SLPlayer new name: 'Jack'.
game addPlayer: jill.
game addPlayer: jack.
game 
]]]

Now you inspect the game either doing it inspect or sending the message inspect to the game as in ==game inspect==. You can also use the doit and go menu of a playground window. 
You should get a picture similar to the one **

+Inspecting the game.>file://figures/inspector1.png|width=70|label=fig:ginspector1+

+Navigating inside the game.>file://figures/inspector2.png|width=70|label=fig:ginspector3+

+Checking that the first tile get effectively the players.>file://figures/inspector3.png|width=70|label=fig:ginspector3+



!!! Displaying players

To help us follow the game 




!!! Finding the tile of a player



[[[
SLGameTest >> testTileOfPlayer
	
	| jill jack game |
	game := SLGame new tileNumber: 12.
	jack := SLPlayer new name: 'Jack'.
	jill := SLPlayer new name: 'Jill'.
	game addPlayer: jill. "first player" 
	game addPlayer: jack. 
	self assert: (game tileOfPlayer: jill) position equals: 1.
]]]

We should 


!!! up to here



[[[
SLGameTest >> testTileForAtDistance
	
	| jill jack game |
	game := SLGame new tileNumber: 12.
	jack := SLPlayer new name: 'Jack'.
	jill := SLPlayer new name: 'Jill'.
	game addPlayer: jill. "first player" 
	game addPlayer: jack. 
	self assert: (game tileFor: jill atDistance: 4) position equals: 5.
]]]

[[[
testPrintingSimpleGame

	| game |
	game := SLGame new tileNumber: 12.
	self assert: game printString equals: '[1][2][3][4][5][6][7][8][9][10][11][12]'
]]]

[[[
SLGameTest >> testGameSetUp

	| Game |
	Game := SLGame new 
		tileNumber: 12; 
		setLadderFrom: 2 to: 4;
		setLadderFrom: 7 to: 9;
		setSnakeFrom: 11 to: 5.
	self assert: (Game at: 2) isLadder. 
	self deny: (Game at: 3) isLadder.
	self assert: (Game at: 11) isSnake.
]]]





















!!! Sending a self-message or a message to another object

(to be put somewhere in the flow)
Remember sending message is making a choice and classes represent choices with different behavior. Therefore sending a message to another object is different than sending a message to self. Especially if the class containing the message does not have subclasses.

For example in the context of the game if we have only one game class we will gain benefit from dispatch.

!!! Creating a hook method
We cannot redefine ==printOn:== or we will duplicate it in all subclasses because we want to change what is printed inside the '[]'.
For a ladder we want to print ==[2 -> 5]==, when there is a player we want to print ==[2<jill>]==

Imagine a solution. 

[[[
SLTile >> printOn: aStream
	your code
]]]
 
What if we define a new method called for example ==printOnInside:== and we define it in the class ==Tile== and we use it for the definition of the ==printOn:== method itself. 

[[[
SLTile >> printOn: aStream
	aStream nextPutAll: '['.
	self printOnInside: aStream.
	aStream nextPutAll: ']'
]]]

Each subclass will then easily be able to provide customized information.




!!! Variations

- A player who lands on an occupied square must go back to the start square.
- If you roll a number higher than the number of squares needs to reach the last square, you must continue moving backwards.

It means that we may have to have a resolution object. 


!!! Solutions

!!!! A first real test

[[[
SLGame >> tileNumber: aNumber

	tiles := Array new: aNumber. 
	1 to: tiles size do: [ :i | 
		tiles at: i put: (SLTile new position: i) ].
]]]

[[[
SLGame >> tileNumber
	
	^ tiles size
]]]

!!!! Accessing on tile

[[[
SLGame >> tileAt: aNumber

	^ tiles at: aNumber
]]]


!!!! Adding players
[[[
SLPlayer >> name: aString 
	name := aString
]]]


[[[
Object subclass: #SLTile
	instanceVariableNames: 'position players'
	classVariableNames: ''
	package: 'SnakesAndLadders'
]]]

[[[
SLGame >> initialize
	players := OrderedCollection new. 
]]]

[[[
SLTile >> addPlayer: aPlayer	
	players add: aPlayer
]]]

[[[
SLTile >> players 
	^ players
]]]
