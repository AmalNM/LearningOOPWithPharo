!! Object-oriented programming in a nutshell
%%@cha:nutshell

This chapter is an overview of the key mechanisms that characterize object-oriented programming:
''objects'', ''classes'', ''inheritance'', ''messages'', ''methods'' and finally ''late binding''.
We will also present ''distribution of responsibilities'' as well as ''delegation'' and ''composition''.
Each of these mechanisms will be used and explained in the book under diverse forms: either a full dedicated chapter or usage in exercises.

We start explaining objects, classes, messages and methods with really simple examples. Then we introduce a little bit more elaborated example: a little file system where we revisit everything and extend it to explain late binding, distribution of responsibilities and delegation.

!!! Objects first 

''Instead of a bit-grinding processor ... plundering data structures, we have a universe of well-behaved objects that courteously ask each other to carry out their various desires.'' [Ingall 81]

Object-oriented programming is about creating objects and interacting with objects by sending them ''messages''.

!!!! Turtles as an example
Imagine that we have a logo turtle (you will implement it in the following chapters). We can do the following: create a turtle, send it messages to make it move, turn and trace some drawnings. 

!!!! Creating an object
First we create a new turtle by sending the message ==new== to the class ==Turtle==. 

[[[
| t |
t := Turtle new. 
]]]

A class is a cast for objects. All the objects, instances of a class, share the same characteristics and behavior. For example, all the turtle instances have a direction and understand messages to rotate and move. However, each turtle has its own value for its direction.
We say that all the instances of a class have the same instance variables but each as private value
for them. 

!!!! Sending messages

The only way to interact with objects is to send them ''messages''.
In the following snippets we send messages
- to create an object , message ==new==,
- to tell the turtle to turn, messsage ==turn:==, and
- to tell the turtle to move, message ==go:==.
[[[
| t |
t := Turtle new. 
t turn: 90.
t go: 100.
t turn: 180. 
t go: 100.
]]]

Messages specify ''what'' the object should do and not how it should do it (this is the duties of methods as we will see later). When we send the message ==go:== we just specify what we expect the receiver to do.  Sending a message is similar to the abstraction provided by procedures or functions in procedural or functional programming language: it hides implementation details. However sending a message is much more than executing a sequence of instructions as we will see later. 

@@note Messages specify ''what'' the object should do and not how it should do it.


!!!! Multiple instances: each with its own state. 
In the following example we show that we can have multiple objects

[[[
| t1 t2 |
t1 := Turtle new. 
t1 turn: 90.
t1 go: 100.
t1 turn: 180. 
t1 go: 100.
t2 := Turtle new.
t2 go: 100.
t2 turn: 40.
t2 go: 100.
]]]

!!!! With counters
Now that you got the main point of objects, we can see that it applies to everything. In Pharo ''everything'' is an object. In fact there is ''nothing'' else, only objects. Here is a little program with counters that you will implement in subsequent chapters. 

We create two counters that we store in variables ==c1== and ==c2== instances of the class ==Counter==. Each counter has its own state but exhibits the same behavior as all the counters defined by the class ==Counter==: 
- when responding to the message ==count==, it returns its value,
- when responding the the message ==increment==, it increment one to its current value. 

[[[
| c1 c2 |
c1 := Counter new.
c2 := Counter new.
c1 count.
>>> 0
c1 increment.
c1 increment.
c1 count. 
>>> 2
c2 count.
>>> 0
c 2 increment.
c2 count. 
>>> 1
]]]

!!! A class: blueprint of objects

A class is a mold or cast of objects. A class specifies two important aspects of their instances:
- Instance ""structure"". All the instances of a class will have the same structure expressed in terms of ''instance variables''. Pay attention that the variables are the same for all the instances of a class but not their values. Each instance has specific values for its instance variables.
- Instance ""behavior"". All the instances share the same behavior even if this one can be different because applied on different values. 

@@note A class is as a blueprint for its instances. 

Let us illustrate this with the class ==Counter==.

!!!! Object structure
Let us study the ==Counter== class definition.  The class ==Counter== defines that all the instances will have one instance variable named ==count== using the expression ==instanceVariableNames: 'count'==. And each instance of the class ==Counter== will have a ==count== variable with a ''different'' value as we showed in the examples above. 

[[[
Object subclass: #Counter
	instanceVariableNames: 'count'
	classVariableNames: ''
	package: 'LOOP'
]]]

!!!! Object behavior
In addition a class is the place that groups the instance behavior. Indeed since all the instances of the class share the ''same'' behavior definitions, such behavior is defined and grouped in a class.

For counters, the class defines how to retrieve the counter value, how to increment 
and decrement the count as used in the messages in the previous code snippets.

Here is the definition of the ""method"" ==increment==. 
It simply adds one to the instance variable ==count==.

[[[
Counter >> increment
	count := count + 1
]]]

When we send a message to a counter for example in the expression ==c1 increment==, 
this method ==increment== will be applied on ''that'' specific object ==c1==.
In the expression ==c1 increment==, ==c1== is called the ""receiver"" of the message ==increment==. 

In the method ==increment==,  the variable ==count== refers to the variable of the ""receiver"" of the message. 

@@note A method specifies ""how"" a computation is performed, step by step contrarily to a message that expresses ""what"" should be performed. 

!!!! Self = receiver
Imagine that now we would like to send a message to the object that receives the message itself. We need a way to refer to the this object. Pharo defines a special variable for this exact purpose: ==self==. 

@@note ==self== always refers to the message receiver that is currently executed.

For example we can implement the method ==incrementByTwo== as follows:

[[[
Counter >> incrementByTwo
	self increment. 
	self increment
]]]

When we execute the expression ==c1 incrementByTwo==, during the execution of the method ==incrementByTwo==, ==self== refers to ==c1==. 

We will explain how a method is found when a message is sent but first we should explain inheritance, i.e., how a class is defined incrementally from a root class.


!!! A simple and naive file system

We start to present a simple example that we use to present and explain the concepts: a simple and naive file system as shown in Figure *@directories*. 
What the figure shows is that we have:
- files that also have a name and a contents. Here we get three different files ==Babar==, ==Astroboy== and ==tintinEtLesPicaros==.
- directories that have a name and can contain other files or directories. Here we get the ==manga==, ==comics==, ==oldcomics== and ==belgiumSchool== directories. Directories can be nested: ==comics== contains three repositories. The ==belgiumSchool== directory contains ==tintinEtLesPicaros==. 

+Some directories and files organised in a file system.>file://figures/comicsFileTree.png|width=50|label=directories+


!!!! Example first 
Since what we want to develop may be a bit blurry for us, let us define first an example. In the rest of this book we will encode examples
as tests that can automatically be executed. For now it would make the discourse too complex, so we just use little code example. 

We create two directories. 
[[[
| dComics doldcomics dManga |
dComics := MFDirectory new name: 'comics'.
dOldComics := MFDirectory new name: 'oldcomics'.
]]]

We add the oldcomics folder to comics and we check that the parent children relationship is well set. 
[[[
dComics addElement: dOldComics. 
dOldComics parent
>>> /comics/
dComics parent
>>> nil
dComics children
>>> #(/comics/oldcomics/)
]]]

We create a new repository and we check that once added to a parent repository, it is included in the 
children.
[[[
dManga := MFDirectory new name: 'manga'.
dComics addElement: dManga. 
dComics children
>>> #(/comics/manga/ /comics/oldcomics/)
]]]

+The ==Directory== class and some instances (directories).>file://figures/DirectoryAndInstancesV0.png|width=40|label=directories+

!!!!Defining a class
Let us start by defining the directory class. 

[[[
Object subclass: #MFDirectory
	instanceVariableNames: 'parent name files'
	classVariableNames: ''
	package: 'MyFS'
]]]

When we create a directory, its files is an empty ordered collection. This is what we express in the following method ==initialize==.

[[[
MFDirectory >> initialize
	files := OrderedCollection new
]]]

An newly created object is sent the message ==initialize== just after its creation. Therefore the ==initialize== method is executed. 

Now we can write the method ==addElement:==. 
(To keep things simple, note that we consider that when a file is added to a directory, it was not belonging to a another directory. This behavior could be implemented by ==aFile moveTo: aDirectory==)
Adding a file to a directory means: (1) that the parent of the file is changed to be the directory to which it is added, (2) that the added file is added to the list of files contained in the directory.

[[[
MFDirectory >> addElement: aFile
	aFile parent: self. 
	files add: aFile
]]]

Note that the method name ==addElement:== is not nice but we chose it on purpose so that you do not believe that delegating
requires that the methods have the same name. An object can delegate its part of duties to another object by simply passing a message. 


We should then define the methods ==name:==, ==parent:==, ==parent==, and ==children== to be able to run our example.

[[[
MFDirectory >> name: aString
	name := aString
]]]

[[[
MFDirectory >> parent: aFile
	parent := aFile
]]]

[[[
MFDirectory >> parent
	^ parent
]]]

[[[
MFDirectory >> children
	^ files
]]]
With such method definitions, how little example should run. It should not print the same results because we did not change the printing of the objects yet. 

!!!! A first little analysis
When we look at the implementation of the method to add a file to a directory we see that the class ==MFDirectory== used another class ==OrderedCollection== to store the information about the files it contains. An ordered collection is a quite complex object: it can insert, remove elements, grow its size, and many more operations. 

We say that the class ==MFDirectory== delegates a part of its duties (to keep the information of the files it contains) to the class ==OrderedCollection==. In addition, when an object is executed, the object to which it may delegate part of its computation may change dynamically. 

Such behavior is not specific to object, in procedural languages we can call another function defined on a data structure. With objects, it is really simple, we can send  a message to another object. 


!!! Printing a directory
Now we would like to get the directory printed in a better way. Without too much explanation, you should know that the method ==printOn: astream== of an object is executed when the system or we send the message ==printString== to an object. So we can specialise it. 

The argument passed to the method ==printOn:== is a stream. A stream is a object in which we can store information one after the other in sequence using the message ==<<==.

[[[
MFDirectory >> printOn: aStream
	aStream << name
]]]

Let us try. 
[[[
| el1 el2 |
el1 := MFDirectory new name: 'comics'.
el2 := MFDirectory new name: 'oldcomics'.
el1 addFile: el2.
el1 printString
>>> comics
el2 printString
>> oldcomics
]]]

+Navigating an object graph by sending message to different object. >file://figures/InstancesRecursion.png|width=35|label=InstancesRecursion+

What would be nice it to get the full path so that we can immediately understand the configuration.
For example we would like to have a first '/' when there is not parent to mimick the pwd unix command and finish with a '/' to indicate
that this is a directory as with the ls command on unix. 

[[[
| el1 el2 |
el1 := MFDirectory new name: 'comics'.
el2 := MFDirectory new name: 'oldcomics'.
el1 addFile: el2.
el1 >> printString. 
/comics/
el2 printString
>> '/comics/oldcomics/'
]]]

A possible definition is the following one:

[[[
MFDirectory >> printOn: aStream
	parent isNil 
		ifTrue: [ aStream << '/' ]
		ifFalse: [ parent printOn: aStream ].
	aStream << name.
	aStream << '/'
]]]

Try it and it should print the expected results.
What do we see with this definition: it is a kind of recursive definition. The name of a directory is in fact the concatenation (here we just add in the stream but this is the same. ) of the name of its parents (as shown in Figure *@InstancesRecursion*).
Similar to a recursive function navigating a structure composed of similar elements (like a linked-list or any structure defined by induction), each parent receives and executes another time the ==printOn:== method and returns the name for its part.

!!! Adding files

Now we want to add files. Once we will have defined files we will be able to have a graph of objects of different kinds represent our file system with directories and files as shown in Figure *@Instances*.

+A graph of objects to represent our file system. >file://figures/Instances.png|width=35|label=Instances+

!!!! An example first

Again let us start with an example.  A file should contain some contents. 

[[[
| el1 dOldComics |
el1 := MFFile new name: 'astroboy'; contents: 'The story of a boy turned into a robot that solved the world'.
dOldComics := MFDirectory new name: 'oldcomics'.
dOldComics addElement: el1. 
el1 printString.
>>>
/oldcomics/astroboy
]]] 


+A new class and its instances.>file://figures/FileV0.png|width=40|label=FileV0+

!!!! A definition
Again a file needs a name, a parent and in addition a contents.

We define the class ==MFFile== as follows (This solution is not satisfactory and we will proposed a much better one later) as shown in Figure *@FileV0*.

[[[
Object subclass: #MyFile
	instanceVariableNames: 'parent name contents'
	classVariableNames: ''
	package: 'MyFS'
]]]

As for the directories we initialize the contents of a file with a default value. 

[[[
MyFile >> initialize
	contents := ''
]]]

We should define the same methods for ==parent:==, ==parent== and ==name:==. This duplication coupled with the fact that we get nearly the same class definition should be a clear big warning. We will address it soon. In addition we will add a method to be able to set the contents of the file ==contents:==.

[[[
MyFile >> name: aString
	name := aString
]]]

[[[
MyFile >> parent: aFile
	parent := aFile
]]]

[[[
MyFile >> parent
	^ parent
]]]

[[[
MyFile >> contents:
	^ contents
]]]

At the stage we should be able to define a file and adding it to a directory.

Now we should redefine the implementation of ==printOn:== to print nicely the name of file:

[[[
MFFile >> printOn: aStream
	aStream << name
]]]

+Printing a file: Sending messages inside a graph of different objects. >file://figures/InstancesRecursion2.png|width=60|label=InstancesRecursion2+


!!! Lessons learned

Before continuing let us step back and analyse the situation. 

[[[
| el1 dOldComics dComics |
el1 := MFFile new name: 'astroboy'; contents: 'The story of a boy turned into a robot that solved the world'.
dOldComics := MFDirectory new name: 'oldcomics'.
dComics := MFDirectory new name: 'comics'.
dComics addElement: dOldComics.
dOldComics addElement: el1. 
el1 printString.
>>>
/comics/oldcomics/astroboy
]]]
[[[
dOldComics printString.
>>>
/comics/oldcomics/
]]] 

What we see is that there is one message and several implementations of methods and that sending a message will find and execute
the correct method. For example, there are two methods ==printOn:== one for file and one for directory but only one message ==printOn:== sent from the ==printString== message.

In addition a method can be defined in terms of messages sent to other objects. The method ==printOn:== for directories is complex and it delegates the same message to other objects, its parents (as illustrated by Figure *@InstancesRecursion2*). The method ==addElement:== delegates to the OrderedCollection sending a different message ==add:==.


!!! Objects: stepping back
Now that we saw some examples of objects, it is time to step back. Objects are defined by the values of their state, their behavior (shared with the other instances of their class) and an identity. 

- ""State."" Each object has specific values. While all the instances of classes have the same structure, each instance has its own values. Each object has a private state. Clients or users of an object cannot access the state of the object if this one does not explicitly expose it by defining a method returning it (such as the message ==count==).
- ""Behavior."" Each object shares the same behavior with all the instances of its class.
- ""Identity."" An object has an identity. It is unique. ==oldcomics== is clearly not the same as ==comics==.


!!! Examples of distribution of responsibilities 

+Two classes understanding similar sets of message.>file://figures/FileDirectoryV1.png|width=60|label=FileDirectoryV1+
!!!! File size 
Let us imagine that we want to compute the size of a directory. Note that the size computation we propose is fantaisit but this is for the sake of the example.To perform such a computation we should also define what is the size of a file. Again let us start with examples (that you will turn into tests in the future.).

First we define that the size of a file is the size of its name and the size of its contents. 

[[[
| el |
el := MFFile new name: 'babar'; contents: 'Babar et Celeste'.
el size = 'babar' size + 'Babar et Celeste' size.
>>> true
]]]

Second we define that the size of a directory is the size of its name plus the size of its files and we add and arbitrary number: 2. 
[[[
| p2 el |
el := MFFile new name: 'babar'.
p2 := MFDirectory new name: 'oldcomics'.
p2 addFile: el. 
p2 size = 'oldcomics' size + 'babar' size + 2
>>> true
]]]

We define two methods ==size== one for each class (see Figure *@FileDirectoryV1*).
[[[
MFFile >> size
	^ contents size + name size
]]]

[[[
MFDirectory >> size
	| sum |
	sum := 0.
	files do: [ :each | sum := sum + each size ].
	sum := sum + name size.
	sum := sum + 2.
	^ sum
]]]

For the purists, such definition in fact fits on one line.

[[[
MFDirectory >> size
	^ name size + (files inject: 0 into: [:s :e | s + e size ]) + 2
]]]

!!!! Search 
Let us imagine that we want to search the files matching a given string. 
Here is an example to set the stage.

[[[
| p el |
p := MFDirectory new name: 'comics'.
el := MFFile new name: 'babar'; contents: 'Babar et Celeste'.
p addFile: el.
el2 := MFFIle new name: 'astroboy; contents: 'super cool robot'.
p addFile: el2.
(p search: 'Ba') asArray
>>> #(/comics/babar)
]]]

To implement this behavior is quite simple: we define two methods one in each class (as shown in Figure *@FileDirectoryV1*).
[[[
MFFile >> search: aString
	^ '*', aString, '*' match: contents
]]]

[[[
MFDirectory >> search: aString
	 ^ self files select: [ :eachFile | eachFile search: aString ]
]]]

!!! Important points
These two examples show several ''important'' points:

!!!! Modular thinking
Each method is modular in the sense that it only focuses on the behavior of the objects specified by the class defining the method. Such method can be built by sending other messages without having to know how such methods are defined.
It also means that we can add a new kind of classes or remove one without having to change the entire system.



# We send ''one'' message and one method amongst the ''multiple'' methods with the same name will be selected and executed. The method is dynamically looked up during execution as we will see later.
# Sending a message is selecting the corresponding method having the same name than the message.  When a message is sent to an object the corresponding method is looked in the class of the message receiver.

@@note Sending a message is making a choice. The system selects for us the correct method to be executed.


!!!! Polymorphic objects 

We created objects (files and directories) that are ''polymorphic'' in the sense that they offer a common set of messages (==search:==, ==printOn:==, ==size==, ==parent:==). This is really powerful because we can compose objects (for example add a new directory or a file) without changing the program. 
Imagine that we add a new kind of directories we can introduce it and reuse extending programs based on ==size== or ==search:== ''without'' changing them. 

@@note Creating polymorphic objects is a really powerful capability. It lets us extend and change programs without breaking them. 





!!! Distribution of responsibilities
This example as well as the printing of files and directories illustrates something fundamental in 
object-oriented programming: the distribution of responsibilities. With the distribution of responsibilities,  each kind of objects is responsible for a specific behavior and a more elaborated behavior is composed out of such different behavior. The size of a directory is computed based on the size of its files by requesting the files to compute their size. 

!!!! Procedural
Let us take some time to compare with procedural thinking. Computing the size of a list of files and directories would have been expressed as a monolitic behavior sketch below:

[[[
sizeOfFiles: files
	| sum | 
	sum := 0.
	files do: [ :aFile | 
		aFile class = MFFile
			ifTrue: [ sum := sum + aFile name size + aFile contents size ].
		aFile class = MFDirectory
			ifTrue: [ 
				| fileSum |
				fileSum := 0.
				each files do: [:anInsideFile | fileSum := fileSum + anInsideFile name size + anInsideFile contents size ].
				sum := sum + fileSum + each name size + 2].
	^ sum	
]]]

While this is example is a bit exagerated, we see several points:
- First, we explicitly check the kind of structures we are manipulating. If this is a file or directory we do something different.
- Second, the logic of the computation is defined inside the ==sizeOFiles:== itself, and not in the entities themselves.   This means in particular that such logic cannot be reused. 
- A part of the implementation logic is exposed and not in control of the object. It means that if we decide to change the internal structure of our classes, we will have to change this function too. 
- Adding a new kind of such as a root directory is not modular. We will have to modify this function. 

What you should also see when you compare the two version is that in the procedural version we have to check the kind of object we manipulate. 
In the object-oriented version, we simply tell the object to perform its own computation and return the result to us. 

@@note Don't ask, tell. Object-oriented programming essence is about sending order not checking state.


!!! So far so good? No!

We have a system with two classes and it offers some behavior composed out of well defined local behavior (see Figure *@FileDirectoryV1*). We can have objects composed out of other objects and messages flow within the graph. Object-oriented programming could stop here.





!!! Inheritance

Object-oriented programming is also based on the ''incremental'' definition of abstractions. This incremental definition mechanism is central to support reuse and extension of abstraction. It is called ''inheritance''. The idea is that you can define a new abstraction (a class) by refining an existing one (its superclass). We said that a subclass inherits from a superclass.

Class inheritance creates trees of classes as shown in Figure *@fig:inhAnimal*. A class in such trees can have instances. All the instances share the behavior defined in their class and superclasses. 
This is within such trees that the system looks up the method corresponding to a message.

Inheritance supports code reuse because instance variable and methods defined on a root concept (class) may be applicable to its refinement. 

We will take a really simple and naive example to illustrate some of the key aspects. This is a rather simple but nice to show the key aspects we want to illustrate: 
- ''incremental definition'': a subclass is defined by expressing the difference with its superclass,
- ''state reuse'': instances of a subclass have at least the state structure of the superclass,
- ''behavior reuse'': when instances of a subclass receive a message, methods of the superclass may be executed, 
- ''behavior redefinition (overriding)'': a subclass may change locally a method definition inherited from its superclass,
- ''behavior extension'': a subclass may extend the behavior of one of its superclasses,
- ''subclass behavior can be injected in superclass behavior'': behavior defined a subclass may be executed in place of the one of a superclass. This is a really important feature of inheritance.


+Two classes with inheritance.>file://figures/FileDirectoryWithInheritanceV1.png|width=60|label=FileDirectoryWithInheritanceV1+



+Two classes with inheritance.>file://figures/FileDirectoryWithInheritanceV2.png|width=60|label=FileDirectoryWithInheritanceV2+
















!!! Reuse of ancestor logic

Imagine that we want to reuse the behavior of animal and to add extra behavior. We can now define a new class ==Dog== which inherits from the class ==Animal==. 

[[[
Animal subclass: #Dog
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'LOOP'
]]]

Since we did not add new instance variables during the definition of the class ==Dog==.
It means that instances of the class ==Dog== will have the same structure as the class ==Animal==.

What we can see is that the methods defined in the class ==Animal== can be executed on the instances 
of ==Dog==. The following example show that the method ==name:==, ==presentYourself== and ==move==
are reused as such. Note that usually when we define a new class it is to add state and new behavior or to extend existing one. 

[[[
(Dog new name: 'Dingo') presentYourself
>>> 'I m a Dog. My name is Dingo, and I walk.'
]]]

Nothing prevents us to define methods in the class ==Dog==. Such methods, however, will only be available for ==Dog== and its subclass instances.


!!! Method lookup

Now it is time to explain what is happening when an object receives a message send. In fact this is really simple but extremely powerful. 
When an object, the message receiver, receives a message, the method with the same selector than the message is looked up starting from the class of receiver. When a method with the same selector is found in a class is returned and executed on the receiver. When there is no method with the same selector, the look up continues in the superclass of the current class.



+Lookup: start in the class of the receiver and look for method in class and superclasses.>file://figures/Ref-LookupBasic.png|width=50|label=fig:Ref-LookupBasic+


explanations here




!!! Specialisation of ancestor behavior
Now we want to show another aspect of inheritance, a subclass can override the behavior defined in a superclass. 
Let us define a new subclass of ==Animal==, named ==Duck==.

[[[
Animal subclass: #Duck
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'LOOP'
]]]

Now we ''redefine'' the method ==move== to return a different value.
[[[
Duck >> move 
	^ 'swim'
]]]

[[[
(Duck new name: 'Donald') presentYourself 
>>> 'I m a Duck. My name is Donald, and I swim.'
]]]


+Overriding superclass behavior.>file://figures/Ref-LookupBasicOverride.png|width=60|label=fig:Ref-LookupBasicOverride+

!!! Sending a message is making a choice

@@note Sending messages is making a choice




!!! Extending ancestor behavior

A subclass may not only specialize but extend the behavior of one of its superclasses. Imagine that we want to define that a duck can swim ''in addition'' to walk. 


Using ==self move== does not work because it creates an endless loop. 
[[[
Duck >> move 
	^ self move , '& swim'
]]]

We need a way to invoke a method of the superclass ==Animal== even though the receiver of the message is an instance of the class ==Duck==.
Pharo offers a special variable called ==super== for this exact purpose. 

@@note ==super== refers to the message receiver (as ==self== does), but it invokes a method defined in classes above the class using it. 

We redefine the method ==move== as follows:
 
[[[
Duck >> move 
	^ super move , '& swim'
]]]

We see the result executing the same code snippet. 

[[[
(Duck new name: 'Donald') presentYourself 
>>> 'I m a Duck. My name is Donald, and I walk & swim.'
]]]

What is happening is the following: 
- the method ==presentYourself== defined on the class ==Animal== is executed and at some point, it executes ==self move==. ==self== here is ==donald== the instance of ==Duck==. 
- the method ==move== defined on the class ==Duck==, is executed

+Extending superclass behavior.>file://figures/Ref-LookupBasicSuper.png|width=60|label=fig:Ref-LookupBasicSuper+

!!! Messages are late bound

move injected from subclasses into superclass' code. 
+Subclass behavior can be invoked from superclass behavior.>file://figures/Ref-LookupLateBinding.png|width=60|label=fig:Ref-LookupLateBinding+


!!! Creating a hook
With the concept of late binding in mind, each time we send a message to self we create a customization point for subclasses.



@@note self sends are creating customization points. 



%!!! Exercises 
%We propose two exercises. First you should turn all the examples into automated tests as explained in the Unit Test %chapter.  This is important because it will helps you for the second exercise.
%As a second exercise, we propose that you introduce a new kind of reposo

%[[[
%| el |
%el := MFRoot new.
%el printString = '/'
%]]]

%[[[
%| el r |
%el := MFDirectory new name: 'comics'.
%r := MFDirectory new. 
%r addFile: el.	
%r printString = '/comics/'
%]]]





!!! Responsibility-driven design (bof)

Objects are responsible to maintain information and provide services
A good design exhibits:
- high cohesion of operations and data within classes 
- low coupling between classes and subsystems
Every method should perform one, well-defined task:
-High level of abstraction 
 write to an interface, not an implementation


 !!! About object-oriented 
 Object-oriented programming
 promotes a distribution of responsibilities:  such distribution of computation over objects is achieved via message passing
 which dynamically looks and applies a potentially different method corresponding to a message.





 Object-oriented design lets you simulate a virtual world, so model the domain objects as you want them to be. Note that we do not have to model the world as it is, but as we want to think about it! In our virtual world, objects can be active and take responsibility for their actions, unlike passive objects in the real world.

  Every domain concept that plays a role in the application and assumes a responsibility is a potential object in the software design

  Don’t distinguish between first and second class objects: everything that has a responsibility and plays a role should be an object.
 
 Well-designed objects have clear responsibilities
 
 
 Data-driven approaches are bad for encapsulation because they focus too quickly on implementation (representation) of objects rather than their interface. Instead, focus on the responsibilities of an object: what data and tasks is it responsible for?

 Responsibility : what you know and maintain

 This will lead you to focus on the interface of an object rather than its representation.
 Identifying responsibilities will help you to discover missing objects, and it will also tell you whether an object is needed in your design or not.


 !!! Design corner: About collaborators and limited responsibility
 As with any paradigm, we can define well designed programs or poor ones. Poor programs are often more buggy, more difficult to understand and reuse.

 Usually an object does not exist in isolation, it often collaborate to implement its behavior. 
 For example, a graphic turtle interacts with numbers, colors, and a graphical canvas to draw on it. A book will interact with a publisher, authors and optionally a collection or library and renter.

 Such collaborators are other objects that do not necessary define the state of the object itself (a canvas is not part of a turtle properties still a turtle interact with it.).

 To help you design good classes you should carefully think about the collaborators of an object.
 Usually an object should not have too many collaborators. 

 Another design guideline is that an object should have a limited set of responsibilities. For example a graphic turtle knows how to display itself and draw on a canvas. A counter knows
 how to store and manipulate a value.


!!! Conclusion

