!! Object-Oriented Programming in a Nutshell
%%@cha:nutshell

This chapter is an overview of the key mechanisms that characterize object-oriented programming:
''objects'', ''classes'', ''inheritance'', ''messages'', ''methods'' and finally ''late binding''. 
Each of these mechanisms will be used and explained in the book under diverse forms: either a full dedicated chapter or usage in exercises. 

!!! Objects first 
Object-oriented programming is about creating objects and interacting with objects by sending them ''messages''.

!!!!! Turtles as an example
Imagine that we have a logo turtle (you will implement it in the following chapters). We can do the following: create a turtle, send it messages to make it move, turn and trace some drawnings. 

!!!!! Creating an object
First we create a new turtle by sending the message ==new== to the class ==Turtle==. 

[[[
| t |
t := Turtle new. 
]]]

A class is a cast for objects. All the objects, instances of a class, share the same characteristics and behavior. For example, all the turtle instances have a direction and understand messages to rotate and move. However, each turtle has its own value for its direction.
We say that all the instances of a class have the same instance variables but each as private value
for them. 

!!!!! Sending messages.

The only way to interact with objects is to send them messages.

[[[
| t |
t := Turtle new. 
t turn: 90.
t go: 100.
t turn: 180. 
t go: 100.
]]]

Messages specify ''what'' the object should do and not how it should do it (this is the duties of methods as we will see later). When we send the message ==go:== we just specify what we expect the receiver to do.  Sending a message is similar to the abstraction provided by procedures or functions in procedural or functional programming language: it hides implementation details. However sending a message is much more than executing a procedure as we will see later. 

!!!!! Multiple instances: each with its own state. 
In the following example we show that we can have multiple objects

[[[
| t1 t2 |
t1 := Turtle new. 
t1 turn: 90.
t1 go: 100.
t1 turn: 180. 
t1 go: 100.
t2 := Turtle new.
t2 go: 100.
t2 turn: 40.
t2 go: 100.
]]]

!!!!! With counters

Now that you got the main point of objects, we can see that it applies to everything. In Pharo ''everything'' is an object. In fact there is ''nothing'' else, only objects. Here is a little program with counters that you will implement in subsequent chapters. 

We create two counters that we store in variables ==c1== and ==c2== instances of the class ==Counter==. Each counter has its own state but exhibits the same behavior as all the counters defined by the class ==Counter==: 
- when responding to the message ==count==, it returns its value,
- when responding the the message ==increment==, it increment one to its current value. 

[[[
| c1 c2 |
c1 := Counter new.
c2 := Counter new.
c1 count.
>>> 0
c1 increment.
c1 increment.
c1 count. 
>>> 2
c2 count.
>>> 0
c 2 increment.
c2 count. 
>>> 1
]]]



!!! Objects: stepping back

Now that we saw some examples of objects, it is time to step back. Objects are defined by their state, their behavior (shared with the other instances of their class) and an identity. 

- ""State."" Each object has specific state. While all the instances of classes have the same structure, each instance has its own values. Each object has a private state. Clients or users of an object cannot access the state of the object if this one does not explicitly expose it by defining a method returning it (such as the message ==count==).
- ""Behavior."" Each object share the same behavior with all the instances of its class.
- ""Identity."" An object has an identity. It is unique. ==c1== is clearly not the same as ==c2==. 

!!! A class: blueprint of objects

A class is a mold or cast of objects. A class specifies two important aspects of their instances:
- Instance ""structure"". All the instances of a class will have the same structure expressed in terms of ''instance variables''. Pay attention that the variables are the same for all the instances of a class but not their values. Each instance has specific values for its instance variables.
- Instance ""behavior"". All the instances share the same behavior even if this one can be different because applied on different values. 

A class is as a blueprint for its instances. Let us see some examples.

!!!! Class counter

The class ==Counter== defines that all the instances will have one instance variable named ==count==. 

[[[
Object subclass: #Counter
	instanceVariableNames: 'count'
	classVariableNames: ''
	package: 'Learning'
]]

In addition a class is the place that defines the behavior of the instances. 
For counters, the class defines how to retrieve the counter value, how to increment 
and decrement the count as used in the messages in the previous code snippets.

Here is the definition of the ""method"" ==increment==. 
It simply adds one to the instance variable count.

[[[
Counter >> increment
	count := count + 1
]]]

Now this method will be applied on specific objects: the ""receiver"" of the message ==increment==. As such, the variable count refers to the one of the ""receiver"" of the message. 

In addition a method specifies ""how"" a computation is performed, step by step contrarily to a message that expresses ""what"" should be performed. 








!!! Inheritance



!!! Playing with Animal 

[[[
Object subclass: #Animal
	instanceVariableNames: 'name'
	classVariableNames: ''
	category: 'WithQuentin'
]]]

[[[
Animal >> name: aString

	name := aString
]]]
	
[[[
Animal >> presentYourself

	^ 'I m a ', self class printString, '. My name is ', name, ', and I move that way: ', self move, '.' 
]]]

[[[
Animal >> move

	^ 'walk'
]]]

!!! Reuse of Ancestor
[[[
Animal subclass: #Dog
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'WithQuentin'
]]]

[[[
(Dog new name: 'Dingo') presentYourself

>>> 'I m a Dog. My name is Dingo, and I move that way: walk.'
]]]

presentYourself is reused. 


!!! Specialisation of ancestor behavior

[[[
Animal subclass: #Duck
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'WithQuentin'
]]]

[[[
Duck >> move 

	^ 'swim'
]]]

[[[
(Duck new name: 'Donald') presentYourself 

>>> 'I m a Duck. My name is Donald, and I move that way: swim.'
]]]

!!! Late bound

move injected from subclasses into superclass' code. 


!!! About interfaces

[[[
Object subclass: #Presenter
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'WithQuentin'
]]]

[[[
Presenter >> present: anObject

	^ 'I m a ', anObject class printString, '. My name is ', anObject name, ', and I move that way: ', anObject move, '.'
]]]

[[[
present: anObject

	^ 'I m a ', anObject class printString, '. My name is ', anObject name, ', and I move that way: ', anObject move, '.'
]]]

[[[
Presenter new 
	present: (Dog new name: 'Dingo')
	
>>>"'I m a Dog. My name is Dingo, and I move that way: walk.'"
]]]

[[[
Object subclass: #Aniplouf
	instanceVariableNames: ''
	classVariableNames: ''
	category: 'WithQuentin'
]]]

Will not be able to reuse Animal. 

[[[
Aniplouf >> move 

	^ 'spatial teleportation'
]]]

[[[
partName

	^ String streamContents: [ :s |
			3 timesRepeat:  [ s nextPut: 'xyzqt' atRandom ]]
]]]
[[[
Aniplouf >> name

	^ self partName
]]]

[[[
Presenter new 
	present: (Aniplouf new )
	
	"" 'I m a Aniplouf. My name is super special entity, and I move that way: spatial teleportation.'"
]]]	