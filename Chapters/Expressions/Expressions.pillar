!! A little expression interpreter
@ch:exp

In this chapter you will build a small mathematical expression interpreter. For example you will be able to build an expression such as  (3 + 4) * 5 and then ask the interpreter to compute its value. You will revisit tests, classes, messages, methods and inheritance.


!!! Starting with a test
We start with constant expression. A constant expression is an expression whose value is always the same, obviously.

Let us start by defining a test case class as follows: 
[[[
TestCase subclass: #EConstantTest
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Expressions'
]]]

 We decided to define one test case class per expression class and this even if at the beginning the classes will not contain many tests. It is easier to define new tests and navigate them.
 
Let us write a first test making sure that when we get a value, sending it the evaluate message returns its value. Note that the message ==assert:equals:== is a special message only define on test case. This message verifies that its first argument is equals to the second argument. 

[[[
EConstantTest >> testEvaluate 
	self assert: (EConstant new value: 5) evaluate equals: 5
]]]

When you compile such test method, the system should prompt you to get a class ==EConstant== defined. 
Let it drives you. Since we need to store the value of a constant expression, let us add an instance variable ==value==
to the class definition. 

At the end you should the following definition for the class ==EConstant==.

[[[
Object subclass: #EConstant
	instanceVariableNames: 'value'
	classVariableNames: ''
	package: 'Expressions'
]]]

We define the method ==value:== to set the value of the instance variable ==value==.
It is simply a method taking one argument and storing it in the ==value== instance variable.

[[[
EConstant >> value: anInteger
	value := anInteger
]]]

You should define the method ==evaluate==: it should return the value of the constant. 

[[[
EConstant >> evaluate
	Your code
]]]

Your test should pass. 

!!! Negation

Now we can start to work on expression negation. Let us write a test and for this define a new test case class named ==ENegationTest==. 

[[[
TestCase subclass: #ENegationTest
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Expressions'
]]]

The test ==testEvaluate== shows that a negation applies to an expression (here a constant) and when we evalute we get the negated value of the constant. 

[[[
ENegationTest >> testEvaluate 
	self assert: (ENegation new expression: (EConstant new value: 5)) evaluate equals: -5
]]]

Let us execute the test and let the system help us to define the class. A negation defines an instance variable to hold the expression that it negates.

[[[
Object subclass: #ENegation
	instanceVariableNames: 'expression'
	classVariableNames: ''
	package: 'Expressions'
]]]

We define a setter method to be able to set the expression under negation.
[[[
ENegation >> expression: anExpression 
	expression := anExpression
]]]

Now the ==evaluate== method should request the evaluation of the expression and negate it. 
To negate a number the Pharo library proposes the message ==negated==. 

[[[
ENegation >> evaluate
	Your code
]]]

+A flat collection of classes.>file://figures/expressions.pdf|width=70|label=figExpression+


!!! Addition

[[[
NegationTest >> testNegated
	
	self assert:(EConstant new value: 6) negated evaluate equals: -6.
	self assert:(EAddition fivePlusThree) negated evaluate equals: -8
]]]
	
	
!!! Multiplication




!!! Design corner: About addition and multiplication model 

We could have just one class called for example binaryOperation and we can add to it an operator and this operator will be either 
the addition or multiplication. It can work and as usual having a working program does not mean that its design is any good. 





!!! Negated as a message


[[[
NegationTest >> testNegationNegated
	self assert:(EConstant new value: 6) negated negated evaluate equals: 6
]]]

[[[
Constant >> negated
	^ ENegation new expression: self
]]]

[[[
NegationTest >> testNegated
	self assert: (EConstant new value: 6) negated evaluate equals: -6.
	self assert: (EAddition fivePlusThree) negated evaluate equals: -8
]]]	


[[[
EAddition >> negated
	^ ENegation new expression: self
]]]

[[[
MultiplicationTest >> testEvaluateNegated
	self assert: (EMultiplication fiveTimesThree) evaluate negated equals: -15
]]]


[[[
EMultiplication >> negated
	^ ENegation new expression: self
]]]

[[[
>> negated
	^ ENegation new expression: self
]]]

!!! Introducing Expression class


+A flat collection of classes.>file://figures/expressionsHierarchy.pdf|width=70|label=figExpressionHierar+

!!! Printing

[[[
AdditionTest >> testPrinting
	self assert: (EAddition fivePlusThree) negated printString equals:  '- ( 5 + 3 )'
]]]

[[[
MultiplicationTest >> testPrinting
	self assert: (EMultiplication fiveTimesThree) negated printString equals:  '- ( 5 * 3 )'
]]]
!!! Optimizing negated on Negation
Example of local redefinition

[[[
ENegation >> negated
	^ expression
]]]

Since the result of a double negation and a single non wrapped expression is the same, we need to define a structural test.

[[[
NegationTest >> testNegatedStructureIsCorrect
	| exp |
	exp := (EConstant new value: 6).
	self assert: exp negated class = ENegation. 
	self assert: exp negated negated equals: exp.
]]]


!!! Solutions

[[[
EConstant >> evaluate
	^ value
]]]

[[[
ENegation >> evaluate
	^ expression evaluate negated
]]]
