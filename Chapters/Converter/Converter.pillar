!! Converter@cha_converterIn this chapter we will implement a little temperature converter between celcius and farhenheit degrees. It is so simple that it will help us to get started with Pharo and also with test driven development.  We will show how to write test to specify the expected results. Writing tests is really important. It is one important tenet of Agile Programming and Test Driven Development (TDD).We will explain later why this is really good to have tests. For now we just implement them. !!! First a testFirst we define a test class named ==TemperatureConverterTest== within the package =='Converter'==. It inherits from the class ==TestCase==. This class is special, any method starting with a =='test'== will be executed automatically, one by one each time on a new instance of the class (to make sure that tests do not interfere with each others). [[[TestCase subclass: #TemperatureConverterTest	instanceVariableNames: ''	classVariableNames: ''	package: 'Converter']]]Converting from Fahrenheit to Celcius is done with a simple linear transformation.The formula to get Fahrenheit from Celcius is F = C * 1.8 + 32. Let us write a test covering such transformation. 30 Celsius should be 86 Fahrenheit. [[[testCelciusToFahrenheit	| converter |	converter := TemperatureConverter new. 	self assert: ((converter convertCelsius: 30) = 86.0)]]]The test is structured the following way:- Its selector starts with ==test==, here the method is named ==testCelciusToFahrenheit==.- It creates a new instance of ==TemperatureConverter== (it is called the context of the test or more technically its fixture).- Then we check using the message ==assert:== that the expected behavior is really happening. The message ==assert:== expects a boolean. Here the expression ==((converter convertCelsius: 30) = 86.0)== returns a boolean. ==true== if the converter returns the value 86.0, false otherwise. The testing frameworks also offers some other assert methods such as ==assert:equals:== that make the error reporting more user friendly. The previousmethod is strictly equivalent to the following one using ==assert:equals:==. This message expects an expression and a result. Here ==(converter convertCelsius: 30)== and ==86.0==. You can use the message you prefer and we suggest to use ==assert:equals:== since it will help you to understand your mistake by saying: 'You expect 86.0 and I got xxx' instead of simply telling you that the result is false. [[[testCelciusToFahrenheit	| converter |	converter := TemperatureConverter new. 	self assert: (converter convertCelsius: 30) equals: 86.0]]]!!! Define the test method (and more)While defining the method ==testCelciusToFahrenheit== using the class browser, the system will tell you that the class ==TemperatureConverter==does not exist and propose you to create it. Just let the system do it. Once you are done. You should have two classes: ==TemperatureConverterTest== and ==TemperatureConverter==. As well as one method. ==testCelciusToFahrenheit==. The test does not pass since we did not implement the conversion method (as shown by the red color in the body of ==testCelciusToFahrenheit==).Note that you entered the method above and the system compiled it. Now in this book we want to make sure that you know about which method we are talking about hence we prefixe the method definition with its class. For example the method ==testCelciusToFahrenheit== in the class ==TemperaturConverterTest== is expressed as follows: [[[TemperaturConverterTest >> testCelciusToFahrenheit	| converter |	converter := TemperatureConverter new. 	self assert: (converter convertCelsius: 30) equals: 86.0]]]!!! The class TemperaturConverterThe class ==TemperaturConverter== is defined as follow: You could have define it before the class  ==TemperaturConverterTest== using the class definition below: [[[Object subclass: #TemperatureConverter	instanceVariableNames: ''	classVariableNames: ''	package: 'Converter']]]This definition in essence, says that- We want to define a new class named ==TemperaturConverter==- It has no instance or class variables (==''== means empty string).- It is packaged in package ==Converter==.Usually when doing Test Driven Development, we focus on tests and let the system propose us some definitions.Then we can define the method as follows. [[[TemperatureConverter >> convertCelsius: anInteger 	"Convert anInteger from celcius to fahrenheit"		^ ((anInteger * 1.8) + 32)]]]The system may tell you that the method is an utility method since it does not use object state. It is a bit true because the converter is a really simple object. For now do not care. Your test should pass. Click on the icon close to the test method to execute it.  !!! Converting from Farhenheit to Celcius Now you got the idea. Let us define a test for the conversion from Fahrenheit to Celcius. [[[TemperatureConverterTest >> testFahrenheitToCelcius	| converter |	converter := TemperatureConverter new. 	self assert: ((converter convertFarhenheit: 86) = 30.0).	self assert: ((converter convertFarhenheit: 50) = 10)]]][[[TemperatureConverter >> convertFarhenheit: anInteger 	^ ((anInteger - 32) / 1.8) ]]]!!! About floatsThe conversion returns floats. Floats are special objects in computer science because it is complex to represent infinite information with a finite space. It may happen that you get a float object that prints as another floats but that in fact is not the same as the one printed. To know more, you can have a look at the Fun with Number chapter in Deep Into Pharo ()*http://books.pharo.org*). The key point is that in computer science you should always avoid to compare the floats using the textual representation. [[[TemperatureConverterTest >> testFToCScale	| converter results exceptedFahrenheit exceptedCelcius |	converter := TemperatureConverter new. 	results := (converter convertFarhenheitFrom: 50 to: 70 by: 2).	exceptedFahrenheit := {50 . 52 . 54 . 56 .  58. 60. 62. 64. 66. 68 . 70}.	exceptedCelcius := #(10.0 11.1 12.2 13.3 14.4 15.5 16.6 17.7 18.8 20.0 21.1 22.2 23.3 24.4 25.5 26.6).		1 to: results size do: [:i |		self assert: (results at: i) = (exceptedCelcius at: i) ] ]]][[[TemperatureConverter >> convertFarhenheitFrom: low to: high by: step 	"Returns pairs (f, c) for all the farhenheit temperatures from a low to an high temperature"		^ (low to: high by: step)		collect: [ :f | f -> (self convertFarhenheit: f) ]]]]!!! Why testing is really important!!! ConclusionIn this chapter we show how define and execute unit tests. We show that there are important to measure our progress and also are an important aid to define clearly what we want to develop. 