!! Converter@cha_converterIn this chapter we will implement a little temperature converter between celcius and farhenheit degrees. It is so simple that it will help us to get started with Pharo and also with test driven development.  We will show how to write test to specify the expected results. Writing tests is really important. It is one important tenet of Agile Programming and Test Driven Development (TDD).We will explain later why this is really good to have tests. For now we just implement them. !!! First a testFirst we define a test class named ==TemperatureConverterTest== within the package =='Converter'==. It inherits from the class ==TestCase==. This class is special, any method starting with a =='test'== will be executed automatically, one by one each time on a new instance of the class (to make sure that tests do not interfere with each others). [[[TestCase subclass: #TemperatureConverterTest	instanceVariableNames: ''	classVariableNames: ''	package: 'Converter']]]Converting from Fahrenheit to Celcius is done with a simple linear transformation.The formula to get Fahrenheit from Celcius is F = C * 1.8 + 32. Let us write a test covering such transformation. 30 Celsius should be 86 Fahrenheit. [[[testCelciusToFahrenheit	| converter |	converter := TemperatureConverter new. 	self assert: ((converter convertCelsius: 30) = 86.0)]]]The test is structured the following way:- Its selector starts with ==test==, here the method is named ==testCelciusToFahrenheit==.- It creates a new instance of ==TemperatureConverter== (it is called the context of the test or more technically its fixture).- Then we check using the message ==assert:== that the expected behavior is really happening. The message ==assert:== expects a boolean. Here the expression ==((converter convertCelsius: 30) = 86.0)== returns a boolean. ==true== if the converter returns the value 86.0, false otherwise. The testing frameworks also offers some other assert methods such as ==assert:equals:== that make the error reporting more user friendly. The previous method is strictly equivalent to the following one using ==assert:equals:==. This message expects an expression and a result. Here ==(converter convertCelsius: 30)== and ==86.0==. You can use the message you prefer and we suggest to use ==assert:equals:== since it will help you to understand your mistake by saying: 'You expect 86.0 and I got xxx' instead of simply telling you that the result is false. [[[testCelciusToFahrenheit	| converter |	converter := TemperatureConverter new. 	self assert: (converter convertCelsius: 30) equals: 86.0]]]!!! Define the test method (and more)While defining the method ==testCelciusToFahrenheit== using the class browser, the system will tell you that the class ==TemperatureConverter==does not exist and propose you to create it. Just let the system do it. Once you are done. You should have two classes: ==TemperatureConverterTest== and ==TemperatureConverter==. As well as one method. ==testCelciusToFahrenheit==. The test does not pass since we did not implement the conversion method (as shown by the red color in the body of ==testCelciusToFahrenheit==).Note that you entered the method above and the system compiled it. Now in this book we want to make sure that you know about which method we are talking about hence we prefixe the method definition with its class. For example the method ==testCelciusToFahrenheit== in the class ==TemperaturConverterTest== is expressed as follows: [[[TemperaturConverterTest >> testCelciusToFahrenheit	| converter |	converter := TemperatureConverter new. 	self assert: (converter convertCelsius: 30) equals: 86.0]]]!!! The class TemperaturConverterThe class ==TemperaturConverter== is defined as follow: You could have define it before the class  ==TemperaturConverterTest== using the class definition below: [[[Object subclass: #TemperatureConverter	instanceVariableNames: ''	classVariableNames: ''	package: 'Converter']]]This definition in essence, says that- We want to define a new class named ==TemperaturConverter==- It has no instance or class variables (==\'\'== means empty string).- It is packaged in package ==Converter==.Usually when doing Test Driven Development with Pharo, we focus on tests and lets the system propose us some definitions.Then we can define the method as follows. [[[TemperatureConverter >> convertCelsius: anInteger 	"Convert anInteger from celcius to fahrenheit"		^ ((anInteger * 1.8) + 32)]]]The system may tell you that the method is an utility method since it does not use object state. It is a bit true because the converter is a really simple object. For now do not care. Your test should pass. Click on the icon close to the test method to execute it.  !!! Converting from Farhenheit to Celcius Now you got the idea. Let us define a test for the conversion from Fahrenheit to Celcius. [[[TemperatureConverterTest >> testFahrenheitToCelcius	| converter |	converter := TemperatureConverter new. 	self assert: ((converter convertFarhenheit: 86) equals: 30.0).	self assert: ((converter convertFarhenheit: 50) equals: 10)]]]Define the method ==convertFarhenheit: anInteger==[[[TemperatureConverter >> convertFarhenheit: anInteger 	"Convert anInteger from fahrenheit to celcius"		^ ((anInteger - 32) / 1.8) ]]]Run the tests they should all pass. !!! About floatsThe conversions method we wrote return floats. Floats are special objects in computer science because it is complex to represent infinite information (such as all the numbers between two consecutive integers) with a finite space (numbers are often represented with a fixed number of bits). In particular we should pay attention when comparing two floats. Here is a surprising case we add two floats and the sum is not equal to their sums. [[[(0.1 + 0.2) = 0.3> false]]]This is because the sum is not just equal to ==0.3==. The sum is in fact the number  ==0.30000000000000004==[[[(0.1 + 0.2)> 0.30000000000000004]]]To solve this problem in Pharo (it is the same in most programming languages), we do not use equality to compare floats but alternate messages such as ==closeTo:== or ==closeTo:precision:== as shown below: [[[(0.1 + 0.2) closeTo: 0.3> true(0.1 + 0.2) closeTo: 0.3 precision: 0.001> true]]]To know more, you can have a look at the Fun with Float chapter in Deep Into Pharo (*http://books.pharo.org*)). The key point is that in computer science you should always avoid to compare the floats naively.So let us go back to our conversion: [[[((52 - 32) / 1.8)> 11.11111111111111]]]In the following expression we check that the result is close to 11.1 with a precision of 0.1. It means that weaccept as result 11 or 11.1[[[((52 -  32) / 1.8) closeTo: 11.1 precision: 0.1> true]]]We can use ==closeTo:precision:== in our tests to make sure that we deal correctly with the float behavior we just described.[[[((52 -  32) / 1.8) closeTo: 11.1 precision: 0.1> true]]]We change our tests to reflect this [[[TemperatureConverterTest >> testFahrenheitToCelcius	| converter |	converter := TemperatureConverter new. 	self assert: ((converter convertFarhenheit: 86) closeTo: 30.0 precision: 0.1).	self assert: ((converter convertFarhenheit: 50) closeTo: 10 precision: 0.1)]]]!!! Rounding resultsThe following expression shows that we may get converted temperature with a too verbose precision. [[[(TemperatureConverter new convertFarhenheit: 52)>11.11111111111111]]]Here just getting 11.1 is enough. There is no need to get the full version. The message ==round: aNumber== rounds the number of decimals[[[(TemperatureConverter new convertFarhenheit: 52) round: 1>11.1]]]Modify the definitions of the two conversion methods to use the message ==round: 1==.Run the tests, they should pass without any modifications. !!! Building a map of degreesOften when you are travelling you would like to have kind of a map of different degrees as follows: Here we want to get the converted values between 50 to 70 farhenheit degrees.[[[(TemperatureConverter new convertFarhenheitFrom: 50 to: 70 by: 2).  > { 50->10.0. 	52->11.1. 	54->12.2. 	56->13.3. 	58->14.4. 	60->15.6. 	62->16.7. 	64->17.8. 	66->18.9. 	68->20.0. 	70->21.1}]]]What we see is that the method ==convertFarhenheitFrom:to:by:== returns an array of pairs.A pair is created using the message ==->== and we can access the pair elements using the message ==key== and ==value== as shown below. [[[| p1 |p1 := 50 -> 10.0.p1 key > 50p1 value> 10.0]]]Let us write a test first. We want to generate map containing as key the farhenheit and as value the converted celcius. Therefore we will get a collection with the map named ==results== and a collection of the expected valuesthat the value of the elements should have. On the two last lines of the test method, using the message ==with:do:== we iterate on both collections in paralleltaking on element of each collection and compare them. [[[TemperatureConverterTest >> testFToCScale	| converter results expectedCelcius |	converter := TemperatureConverter new. 	results := (converter convertFarhenheitFrom: 50 to: 70 by: 2).	expectedCelcius := #(10.0 11.1 12.2 13.3 14.4 15.5 16.6 17.7 18.8 20.0 21.1).		results with: expectedCelcius 		do: [ :res :cel | res value closeTo: cel ] ]]]Now we are reading to implement the method ==convertFarhenheitFrom: low to: high by: step==.Using the message ==to:by:==, we create an interval to generate the collection of numbers starting at low and ending up at high using the increment step. Then we use the message ==collect:== which applies a block to a collection and returns a collection containing all the values returned by the block application. Here we just create a pair whose key is the farhenheit and whose value is its converted celcius value.[[[TemperatureConverter >> convertFarhenheitFrom: low to: high by: step 	"Returns a collection of pairs (f, c) for all the farhenheit temperatures from a low to an high temperature"		^ (low to: high by: step)		collect: [ :f | f -> (self convertFarhenheit: f) ]]]][[[TemperatureConverter >> convertFarhenheitFrom: low to: high by: step 	"Returns pairs (f, c) for all the farhenheit temperatures from a low to an high temperature"		^ (low to: high by: step)		collect: [ :f | f -> (self convertFarhenheit: f) ]]]]!!! Why testing is really importantUnfortunately, many developers believe that tests are a waste of their time.After all, ''they'' do not write bugs, only ''other'' programmers do that. Mostof us have said, at some time or other: ''I would write tests if I had moretime.'' If you never write a bug, and if your code will never be changed in thefuture, then indeed tests are a waste of your time. However, this most likelyalso means that your application is trivial, or that it is not used by you oranyone else. Think of tests as an investment for the future: having a suite oftests is quite useful now, but it will be ''extremely'' useful when yourapplication, or the environment in which it runs, changes in the future.Tests play several roles. - First, they help specify what a program expected and produce.- Second, they provide documentation of the functionality that they cover. This documentation is active: watching the tests pass tells you that the documentation is up to date. - Third, tests help developers to confirm that some changes that they have just made to a package have not broken anything else in the system, and to find the parts that break when that confidence turns out to be misplaced. - Finally, writing tests during, or even before,  programming forces you to think about the functionality that you want to design, ''and how it should appear to the client code'', rather than about how to implement it.By writing the tests first, i.e., before the code, you are compelled to state the context in which your functionality will run, the way it will interact with the client code, and the expected results. Your code will improve. Try it.We cannot test all aspects of any realistic application. Covering a completeapplication is simply impossible and should not be the goal of testing. Evenwith a good test suite some bugs will still creep into the application, wherethey can lay dormant waiting for an opportunity to damage your system. If youfind that this has happened, take advantage of it! As soon as you uncover thebug, write a test that exposes it, run the test, and watch it fail. Now you canstart to fix the bug: the test will tell you when you are done.!!! ConclusionIn this chapter we built a simple temperature converter. We showed how define and execute unit tests using a Test Driven approach. The interest in testing and Test Driven Development is not limited to Pharo. Automated testing has become a hallmark of the ''Agile software development'' movement, and any software developer concerned with improvingsoftware quality would do well to adopt it. We showed that there are important to measure our progress and also are an important aid to define clearly what we want to develop. 