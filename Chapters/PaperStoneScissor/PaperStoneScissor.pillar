{ "title" : "Stone Paper Scissors"}@cha_converter!! Starting with a couple of tests[[[TestCase subclass: #StonePaperScissorsTest	instanceVariableNames: ''	classVariableNames: ''	package: 'StonePaperScissors']]][[[StonePaperScissorsTest >> testPaperIsWinning	self assert: (Stone new play: Paper new) = #paper]]][[[StonePaperScissorsTest >> testScissorIsWinning	self assert: (Scissors new play: Paper new) = #scissors]]][[[	StonePaperScissorsTest >> testStoneAgainsStone	self assert: (Stone new play: Stone new) = #draw]]]!! Creating the classes[[[Object subclass: #Paper	instanceVariableNames: ''	classVariableNames: ''	package: 'StonePaperScissors']]]	[[[Object subclass: #Scissors	instanceVariableNames: ''	classVariableNames: ''	package: 'StonePaperScissors']]][[[Object subclass: #Stone	instanceVariableNames: ''	classVariableNames: ''	package: 'StonePaperScissors']]]They could share a common superclass!! With messages[[[StonePaperScissorsTest >> testPaperIsWinning	self assert: (Stone new play: Paper new) = #paper]]][[[Stone >> play: anotherTool	^ anotherTool playAgainstStone: self]]][[[Paper >> playAgainstStone: aStone	^ #paper]]]The test should pass now. !!! playAgainstStone:[[[Scissors >> playAgainstStone: aStone	^ #stone]]][[[Stone >> playAgainstStone: aStone	^ #draw]]]!!! Scissors now[[[StonePaperScissorsTest >> testScissorIsWinning	self assert: (Scissors new play: Paper new) = #scissors]]][[[Scissors >> play: anotherTool	^ anotherTool playAgainstScissors: self]]][[[Scissors >> playAgainstScissors: aScissors	^ #draw]]][[[Paper >> playAgainstScissors: aScissors	^ #scissors]]][[[Stone >> playAgainstScissors: aScissors	^ #stone]]]!!! Paper now[[[Paper >> play: anotherTool	^ anotherTool playAgainstPaper: self]]][[[Scissors >> playAgainstPaper: aPaper	^ #scissors]]][[[Paper >> playAgainstPaper: aPaper	^ #draw]]][[[Stone >> playAgainstPaper: aPaper	^ #paper]]]+An overview of a possible solution using double dispatch.>file://figures/StonePaperScissors.pdf|width=80+The methods could return a value such as 1 when the receiver wins, 0 when there is draw and -1 when the receiver loses.  Add new tests and check this version. !! A Better APIBoth previous approaches either returning a symbol or a number are working but we can ask ourselves how the client will use this code. Most of the time he will have to check again the returned result to perform some actions.[[[	(aGameElement play: anotherGameElement) = 1 		ifTrue: [ do something for aGameElement]		(aGameElement play: anotherGameElement) = -1 ]]]So all in all, while this was a good exercise to help you understand that we do not need to have explicit conditionals and that we can use message passing instead, it felt a bit disappointing. But there is a much better solution using double dispatch. The idea is to pass the action to be executed to the object and that the object decide what to do. [[[Paper new competeWith: Paper new	onDraw: [ Game incrementDraw ]	onReceiverWin: [ ]	onReceiverLose: [ ]]]][[[Paper new competeWith: Stone new	onDraw: [ ]	onReceiverWin: [ Game incrementPaper ]	onReceiverLose: [ ]]]]Propose an implementation.!!! Possible implementation[[[Paper >> play: anElement onDraw: aDrawBlock onWin: aWinBlock onLose: aLoseBlock	^ anElement		playAgainstPaper: self		onDraw: aDrawBlock		onReceiverWin: aWinBlock		onReceiverLose: aLoseBlock]]][[[Paper >> playAgainstPaper: anElement onDraw: aDrawBlock onReceiverWin: aWinBlock onReceiverLose: aLoseBlock	^ aDrawBlock value]]]!! Conclusion